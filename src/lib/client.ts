// Code generated by the Encore v1.25.0 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = 'http://localhost:4000'

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
  return `https://${name}-worship-yoz2.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
  return Environment(`pr${pr}`)
}

/**
 * Client is an API client for the worship-yoz2 Encore application.
 */
export default class Client {
  public readonly ai: ai.ServiceClient
  public readonly app: app.ServiceClient
  public readonly file: file.ServiceClient
  public readonly identity: identity.ServiceClient
  public readonly team: team.ServiceClient

  /**
   * @deprecated This constructor is deprecated, and you should move to using BaseURL with an Options object
   */
  constructor(target: string, token?: string)

  /**
   * Creates a Client for calling the public and authenticated APIs of your Encore application.
   *
   * @param target  The target which the client should be configured to use. See Local and Environment for options.
   * @param options Options for the client
   */
  constructor(target: BaseURL, options?: ClientOptions)
  constructor(
    target: string | BaseURL = 'prod',
    options?: string | ClientOptions
  ) {
    // Convert the old constructor parameters to a BaseURL object and a ClientOptions object
    if (!target.startsWith('http://') && !target.startsWith('https://')) {
      target = Environment(target)
    }

    if (typeof options === 'string') {
      options = { auth: options }
    }

    const base = new BaseClient(target, options ?? {})
    this.ai = new ai.ServiceClient(base)
    this.app = new app.ServiceClient(base)
    this.file = new file.ServiceClient(base)
    this.identity = new identity.ServiceClient(base)
    this.team = new team.ServiceClient(base)
  }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
  /**
   * By default the client will use the inbuilt fetch function for making the API requests.
   * however you can override it with your own implementation here if you want to run custom
   * code on each API request made or response received.
   */
  fetcher?: Fetcher

  /** Default RequestInit to be used for the client */
  requestInit?: Omit<RequestInit, 'headers'> & {
    headers?: Record<string, string>
  }

  /**
   * Allows you to set the auth token to be used for each request
   * either by passing in a static token string or by passing in a function
   * which returns the auth token.
   *
   * These tokens will be sent as bearer tokens in the Authorization header.
   */
  auth?: string | AuthDataGenerator
}

export namespace ai {
  export class ServiceClient {
    private baseClient: BaseClient

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient
    }

    /**
     * Chat answer a query.
     */
    public async Chat(
      method: 'POST',
      appID: string,
      body?: BodyInit,
      options?: CallParameters
    ): Promise<Response> {
      return this.baseClient.callAPI(
        method,
        `/v1/apps/${encodeURIComponent(appID)}/chat`,
        body,
        options
      )
    }
  }
}

export namespace app {
  /**
   * AddDomainParams is params for AddDomain.
   */
  export interface AddDomainParams {
    domain: string
  }

  /**
   * AddDomainResponse is response for AddDomain.
   */
  export interface AddDomainResponse {
    domain_id: string
  }

  /**
   * CreateAppParams is the input for CreateApp.
   */
  export interface CreateAppParams {
    name: string
  }

  /**
   * CreateAppResponse is the output for CreateApp.
   */
  export interface CreateAppResponse {
    app: entity.App
  }

  /**
   * GetAppByDomainResponse is response for GetAppByDomain.
   */
  export interface GetAppByDomainResponse {
    app: entity.App
  }

  /**
   * GetAppBySlugResponse represents the response of GetAppBySlug
   */
  export interface GetAppBySlugResponse {
    app: entity.App
  }

  /**
   * GetAppResponse is the response for GetApp.
   */
  export interface GetAppResponse {
    app: entity.App
  }

  /**
   * GetAppsResponse is the response for GetApps.
   */
  export interface GetAppsResponse {
    apps: entity.App[]
  }

  /**
   * SlugAvailableParams is the input for SlugAvailable.
   */
  export interface SlugAvailableParams {
    /**
     * Slug is the slug to check.
     */
    slug: string
  }

  /**
   * SlugAvailableResponse is the output for SlugAvailable.
   */
  export interface SlugAvailableResponse {
    /**
     * Available is true if the slug is available.
     */
    available: boolean
  }

  /**
   * UpdateAppParams is the input for UpdateApp.
   */
  export interface UpdateAppParams {
    /**
     * Name is the name of the application.
     */
    name: string

    /**
     * Slug is the slug of the application.
     */
    slug: string

    /**
     * GithubRepo is the connected Github repository of the application (if any).
     */
    githubRepo: string

    /**
     * OpenAIKey is the OpenAI key of the application.
     */
    openaiKey: string

    /**
     * ResetPublicAPIKey resets the public API key.
     */
    resetPublicApiKey: boolean

    /**
     * ResetSecretDevAPIKey resets the secret test API key.
     */
    resetSecretDevApiKey: boolean

    /**
     * Prompt is the prompt of the application.
     */
    Prompt: string

    /**
     * Model is the AI model of the application.
     */
    Model: string

    /**
     * PublicAPIKey is the public API key of the application.
     */
    PublicAPIKey: string

    /**
     * DevAPIKey is the secret test API key of the application.
     */
    DevAPIKey: string

    /**
     * Config is the application configuration.
     */
    Config: schema.AppConfig
  }

  /**
   * UpdateAppResponse is the output for UpdateApp.
   */
  export interface UpdateAppResponse {
    app: entity.App
  }

  export class ServiceClient {
    private baseClient: BaseClient

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient
    }

    /**
     * AddDomain adds a domain to an app.
     */
    public async AddDomain(
      appID: string,
      params: AddDomainParams
    ): Promise<AddDomainResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/apps/${encodeURIComponent(appID)}/domain`,
        JSON.stringify(params)
      )
      return (await resp.json()) as AddDomainResponse
    }

    /**
     * CreateApp creates a new app.
     */
    public async CreateApp(
      teamID: string,
      params: CreateAppParams
    ): Promise<CreateAppResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/teams/${encodeURIComponent(teamID)}/apps`,
        JSON.stringify(params)
      )
      return (await resp.json()) as CreateAppResponse
    }

    /**
     * DeleteApp deletes the app.
     */
    public async DeleteApp(teamID: string, appID: string): Promise<void> {
      await this.baseClient.callAPI(
        'DELETE',
        `/teams/${encodeURIComponent(teamID)}/apps/${encodeURIComponent(appID)}`
      )
    }

    /**
     * GetApp returns the app by ID.
     */
    public async GetApp(
      teamID: string,
      appID: string
    ): Promise<GetAppResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/teams/${encodeURIComponent(teamID)}/apps/${encodeURIComponent(appID)}`
      )
      return (await resp.json()) as GetAppResponse
    }

    /**
     * GetAppByDomain returns an AI application by its domain.
     */
    public async GetAppByDomain(
      domain: string
    ): Promise<GetAppByDomainResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/domains/${encodeURIComponent(domain)}/app`
      )
      return (await resp.json()) as GetAppByDomainResponse
    }

    /**
     * GetAppBySlug returns an AI application by its slug.
     */
    public async GetAppBySlug(slug: string): Promise<GetAppBySlugResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/apps/${encodeURIComponent(slug)}`
      )
      return (await resp.json()) as GetAppBySlugResponse
    }

    /**
     * GetApps returns all the apps that team has access to.
     */
    public async GetApps(teamID: string): Promise<GetAppsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/teams/${encodeURIComponent(teamID)}/apps`
      )
      return (await resp.json()) as GetAppsResponse
    }

    /**
     * SlugAvailable checks if the slug is available.
     */
    public async SlugAvailable(
      appID: string,
      params: SlugAvailableParams
    ): Promise<SlugAvailableResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        slug: params.slug
      })

      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/apps/${encodeURIComponent(appID)}/slug-available`,
        undefined,
        { query }
      )
      return (await resp.json()) as SlugAvailableResponse
    }

    /**
     * UpdateApp updates the app.
     */
    public async UpdateApp(
      teamID: string,
      appID: string,
      params: UpdateAppParams
    ): Promise<UpdateAppResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'PATCH',
        `/teams/${encodeURIComponent(teamID)}/apps/${encodeURIComponent(
          appID
        )}`,
        JSON.stringify(params)
      )
      return (await resp.json()) as UpdateAppResponse
    }
  }
}

export namespace file {
  /**
   * AddFileParams is the input for AddFile.
   */
  export interface AddFileParams {
    /**
     * SourceID is the id of the source.
     */
    sourceId: string

    /**
     * File is the file to add.
     */
    file: FileData
  }

  /**
   * AddFileResponse is the output for AddFile.
   */
  export interface AddFileResponse {
    /**
     * File is the created file.
     */
    file: entity.File
  }

  /**
   * CreateSourceParams is the input for CreateSource.
   */
  export interface CreateSourceParams {
    /**
     * Type is the type of the Source.
     */
    type: source.Type

    /**
     * Config is the configuration of the Source.
     */
    config: schema.SourceConfig
  }

  /**
   * CreateSourceResponse is the output for CreateSource.
   */
  export interface CreateSourceResponse {
    source: entity.Source
  }

  /**
   * DeleteFiles deletes the files.
   */
  export interface DeleteFilesParams {
    /**
     * Files is the list of file ids to delete.
     */
    files: string[]
  }

  /**
   * FileData is the section of a file.
   */
  export interface FileData {
    /**
     * Type is the type of the file.
     */
    type: string

    /**
     * Path is the path of the file.
     */
    path: string

    /**
     * Name is the name of the file.
     */
    name: string

    /**
     * Content is the content of the file.
     */
    content: string
  }

  /**
   * GetFilesParams is the input for GetFiles.
   */
  export interface GetFilesParams {
    sources: string[]
  }

  /**
   * GetFilesResponse is the output for GetFiles.
   */
  export interface GetFilesResponse {
    files: entity.File[]
  }

  /**
   * GetSourcesResponse is the output for GetSources.
   */
  export interface GetSourcesResponse {
    sources: entity.Source[]
  }

  export class ServiceClient {
    private baseClient: BaseClient

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient
    }

    /**
     * AddFile adds a file to the app.
     */
    public async AddFile(
      appID: string,
      params: AddFileParams
    ): Promise<AddFileResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/apps/${encodeURIComponent(appID)}/files`,
        JSON.stringify(params)
      )
      return (await resp.json()) as AddFileResponse
    }

    /**
     * CreateSource creates a new source for the app.
     */
    public async CreateSource(
      appID: string,
      params: CreateSourceParams
    ): Promise<CreateSourceResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/apps/${encodeURIComponent(appID)}/sources`,
        JSON.stringify(params)
      )
      return (await resp.json()) as CreateSourceResponse
    }

    /**
     * DeleteFile deletes the file.
     */
    public async DeleteFile(appID: string, fileID: string): Promise<void> {
      await this.baseClient.callAPI(
        'DELETE',
        `/apps/${encodeURIComponent(appID)}/files/${encodeURIComponent(fileID)}`
      )
    }

    /**
     * DeleteFiles deletes the files.
     */
    public async DeleteFiles(
      appID: string,
      params: DeleteFilesParams
    ): Promise<void> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        files: params.files.map(v => v)
      })

      await this.baseClient.callAPI(
        'DELETE',
        `/apps/${encodeURIComponent(appID)}/files`,
        undefined,
        { query }
      )
    }

    /**
     * DeleteSource deletes the source.
     */
    public async DeleteSource(appID: string, sourceID: string): Promise<void> {
      await this.baseClient.callAPI(
        'DELETE',
        `/apps/${encodeURIComponent(appID)}/sources/${encodeURIComponent(
          sourceID
        )}`
      )
    }

    /**
     * GetFiles returns the files for the app.
     */
    public async GetFiles(
      appID: string,
      params: GetFilesParams
    ): Promise<GetFilesResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        sources: params.sources.map(v => v)
      })

      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/apps/${encodeURIComponent(appID)}/files`,
        undefined,
        { query }
      )
      return (await resp.json()) as GetFilesResponse
    }

    /**
     * GetSources returns the sources for the app.
     */
    public async GetSources(appID: string): Promise<GetSourcesResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/apps/${encodeURIComponent(appID)}/sources`
      )
      return (await resp.json()) as GetSourcesResponse
    }
  }
}

export namespace identity {
  /**
   * CreateNewUserParams is the input for CreateNewUser.
   */
  export interface CreateNewUserParams {
    fullName: string
    email: string
    avatarUrl: string
    providerId: string
  }

  /**
   * CreateNewUserResponse is the output for CreateNewUser.
   */
  export interface CreateNewUserResponse {
    user: entity.User
  }

  /**
   * MeResponse is the output for Me.
   */
  export interface MeResponse {
    user: entity.User
  }

  /**
   * UpdateCurrentUserParams is the input for UpdateUser.
   */
  export interface UpdateCurrentUserParams {
    fullName: string
    email: string
    avatarUrl: string
    hasOnboarded: boolean
  }

  /**
   * UpdateCurrentUserResponse is the output for UpdateUser.
   */
  export interface UpdateCurrentUserResponse {
    /**
     * User is the user that was created or updated.
     */
    user: entity.User
  }

  export class ServiceClient {
    private baseClient: BaseClient

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient
    }

    /**
     * CreateNewUser creates a new user with personal team.
     */
    public async CreateNewUser(
      params: CreateNewUserParams
    ): Promise<CreateNewUserResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/users`,
        JSON.stringify(params)
      )
      return (await resp.json()) as CreateNewUserResponse
    }

    /**
     * Me returns the current logged in user.
     */
    public async Me(): Promise<MeResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI('GET', `/me`)
      return (await resp.json()) as MeResponse
    }

    /**
     * UpdateCurrentUser updates the current logged in user.
     */
    public async UpdateCurrentUser(
      params: UpdateCurrentUserParams
    ): Promise<UpdateCurrentUserResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'PATCH',
        `/me`,
        JSON.stringify(params)
      )
      return (await resp.json()) as UpdateCurrentUserResponse
    }
  }
}

export namespace team {
  /**
   * CreateTeamParams is the input for CreateTeam.
   */
  export interface CreateTeamParams {
    name: string
    slug: string
  }

  /**
   * CreateTeamResponse is the output for CreateTeam.
   */
  export interface CreateTeamResponse {
    team: entity.Team
  }

  /**
   * FileStats is the file stats for the team token usage and limits.
   */
  export interface FileStats {
    used: number
    remaining: number
    limit: number
  }

  /**
   * GetTeamResponse is the output for GetTeam.
   */
  export interface GetTeamResponse {
    team: entity.Team
  }

  /**
   * GetTeamsResponse is the output for GetTeams.
   */
  export interface GetTeamsResponse {
    teams: entity.Team[]
  }

  /**
   * StatusResponse is the output for FileStats.
   */
  export interface StatusResponse {
    fileStats: FileStats
  }

  export class ServiceClient {
    private baseClient: BaseClient

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient
    }

    /**
     * CreateTeam creates a new team.
     */
    public async CreateTeam(
      params: CreateTeamParams
    ): Promise<CreateTeamResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'POST',
        `/teams`,
        JSON.stringify(params)
      )
      return (await resp.json()) as CreateTeamResponse
    }

    /**
     * GetTeam returns the team with the given ID.
     */
    public async GetTeam(teamID: string): Promise<GetTeamResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/teams/${encodeURIComponent(teamID)}`
      )
      return (await resp.json()) as GetTeamResponse
    }

    /**
     * GetTeams returns all teams that the authenticated user is a member of.
     */
    public async GetTeams(): Promise<GetTeamsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI('GET', `/teams`)
      return (await resp.json()) as GetTeamsResponse
    }

    /**
     * Status returns the status of the team.
     */
    public async Status(teamID: string): Promise<StatusResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callAPI(
        'GET',
        `/teams/${encodeURIComponent(teamID)}/status`
      )
      return (await resp.json()) as StatusResponse
    }
  }
}

export namespace entity {
  /**
   * App is the model entity for the App schema.
   */
  export interface App {
    /**
     * ID is application's unique identifier.
     */
    id: string

    /**
     * CreatedBy defines the user that created the application.
     */
    createdBy: string

    /**
     * TeamID is the ID of the team that owns the application.
     */
    teamId: string

    /**
     * Name is the name of the application.
     */
    name: string

    /**
     * Slug is the slug of the application.
     */
    slug: string

    /**
     * GithubRepo is the connected Github repository of the application (if any).
     */
    githubRepo: string

    /**
     * OpenAIKey is the OpenAI key of the application.
     */
    openaiKey: string

    /**
     * IsStarter defines if the application is a starter application.
     */
    isStarter: boolean

    /**
     * PublicAPIKey is the public API key of the application.
     */
    publicApiKey: string

    /**
     * SecretDevAPIKeyis the secret dev API key of the application.
     */
    secretDevApiKey: string

    /**
     * Model is the AI model to use for the application.
     */
    model: string

    /**
     * Prompt is the system prompt to use for the application.
     */
    prompt: string

    /**
     * Config is the application configuration.
     */
    config: schema.AppConfig

    /**
     * CreatedAt is the time the application was created.
     */
    createdAt: string

    /**
     * UpdatedAt is the time the application was last updated.
     */
    updatedAt: string
  }

  /**
   * File is the model entity for the File schema.
   */
  export interface File {
    /**
     * ID of the file.
     */
    id: string

    /**
     * Name is the name of the file.
     */
    name: string

    /**
     * DetectedType is the type of the file.
     */
    detectedType: string

    /**
     * AppID is the ID of the app that owns the file.
     */
    appId: string

    /**
     * Path is the path of the file.
     */
    path: string

    /**
     * Checksum is the checksum of the file.
     */
    checksum: string

    /**
     * SourceID is the ID of the source of the file.
     */
    sourceId: string

    /**
     * Meta is the metadata of the file.
     */
    meta: schema.FileMeta

    /**
     * CreatedAt is the time when the file was created.
     */
    createdAt: string

    /**
     * UpdatedAt is the time when the file was last updated.
     */
    updatedAt: string
  }

  /**
   * Source is an enabled source of file upload.
   * It gets created when a user uploads a file to a knowledge box.
   */
  export interface Source {
    /**
     * ID is the unique identifier of the Source.
     */
    id: string

    /**
     * CreatedAt is the time when the Source was created.
     */
    createdAt: string

    /**
     * UpdatedAt is the time when the Source was last updated.
     */
    updatedAt: string

    /**
     * AppID is the ID of the App that this Source belongs to.
     */
    appId: string

    /**
     * Type is the type of the Source.
     */
    type: source.Type

    /**
     * Config is the configuration of the Source.
     */
    config: schema.SourceConfig
  }

  /**
   * Team holds the group data that user is part of.
   */
  export interface Team {
    /**
     * ID is the unique identifier of the team.
     */
    id: string

    /**
     * Name is the name of the team.
     */
    name: string

    /**
     * Slug is the slug of the team.
     */
    slug: string

    /**
     * IsPersonal is true if the team is a personal team.
     */
    isPersonal: boolean

    /**
     * IsEnterprisePlan is true if the team is on an enterprise plan.
     */
    isEnterprisePlan: boolean

    /**
     * StripeCustomerID is the ID of the Stripe customer.
     */
    stripeCustomerId: string

    /**
     * StripeSubscriptionID is the ID of the Stripe subscription.
     */
    stripePriceId: string

    /**
     * PlanDetails is the details of the plan the team is on.
     */
    planDetails: schema.PlanDetails

    /**
     * BillingCycleStartsOn is the time when the billing cycle starts.
     */
    billingCycleStartsOn: string

    /**
     * CreatedBy is the ID of the user that created the team.
     */
    createdBy: string

    /**
     * CreatedAt is the time when the team was created.
     */
    createdAt: string

    /**
     * UpdatedAt is the time when the team was last updated.
     */
    updatedAt: string
  }

  /**
   * User holds the schema definition for the User entity.
   */
  export interface User {
    /**
     * ID is the unique identifier of the user.
     */
    id: string

    /**
     * FullName is the full name of the user.
     */
    fullName: string

    /**
     * Email is the email of the user.
     */
    email: string

    /**
     * AvatarURL is the URL of the user's avatar.
     */
    avatarUrl: string

    /**
     * HasOnboarded is true if the user has completed the onboarding process.
     */
    hasOnboarded: boolean

    /**
     * CreatedAt is the time when the user was created.
     */
    createdAt: string

    /**
     * UpdatedAt is the time when the user was last updated.
     */
    updatedAt: string
  }
}

export namespace schema {
  /**
   * AppConfig is the config for an App.
   */
  export interface AppConfig {
    placeholder: string
    dontKnow: string
    temperature: number
    tokenLength: number
    topP: number
    topK: number
    minContentLength: number
    contextSize: number
    contextSimilarity: number
  }

  /**
   * FileMeta is the metadata for the File.
   */
  export interface FileMeta {
    title: string
  }

  /**
   * PlanDetails of the Team.
   */
  export interface PlanDetails {
    customPageFetcher: boolean
    quotas: Quotas
  }

  /**
   * Quotas contains the embedding quota of the Team.
   */
  export interface Quotas {
    embeddings: number
  }

  /**
   * SourceConfig holds the configuration for a Source.
   */
  export interface SourceConfig {
    /**
     * URL to the source
     *
     * Example: Github, Website, File Upload, API Upload
     */
    url: string

    /**
     * Branch to use for Github
     */
    branch: string
  }
}

export namespace source {
  /**
   * Type defines the type for the "type" enum field.
   */
  export type Type = string
}

function encodeQuery(parts: Record<string, string | string[]>): string {
  const pairs: string[] = []
  for (const key in parts) {
    const val = (
      Array.isArray(parts[key]) ? parts[key] : [parts[key]]
    ) as string[]
    for (const v of val) {
      pairs.push(`${key}=${encodeURIComponent(v)}`)
    }
  }
  return pairs.join('&')
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(
  record: Record<K, V | undefined>
): Record<K, V> {
  for (const key in record) {
    if (record[key] === undefined) {
      delete record[key]
    }
  }
  return record as Record<K, V>
}

// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, 'method' | 'body' | 'headers'> & {
  /** Headers to be sent with the request */
  headers?: Record<string, string>

  /** Query parameters to be sent with the request */
  query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () => string | undefined

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch

const boundFetch = fetch.bind(this)

class BaseClient {
  readonly baseURL: string
  readonly fetcher: Fetcher
  readonly headers: Record<string, string>
  readonly requestInit: Omit<RequestInit, 'headers'> & {
    headers?: Record<string, string>
  }
  readonly authGenerator?: AuthDataGenerator

  constructor(baseURL: string, options: ClientOptions) {
    this.baseURL = baseURL
    this.headers = {
      'Content-Type': 'application/json',
      'User-Agent': 'worship-yoz2-Generated-TS-Client (Encore/v1.25.0)'
    }
    this.requestInit = options.requestInit ?? {}

    // Setup what fetch function we'll be using in the base client
    if (options.fetcher !== undefined) {
      this.fetcher = options.fetcher
    } else {
      this.fetcher = boundFetch
    }

    // Setup an authentication data generator using the auth data token option
    if (options.auth !== undefined) {
      const auth = options.auth
      if (typeof auth === 'function') {
        this.authGenerator = auth
      } else {
        this.authGenerator = () => auth
      }
    }
  }

  // callAPI is used by each generated API method to actually make the request
  public async callAPI(
    method: string,
    path: string,
    body?: BodyInit,
    params?: CallParameters
  ): Promise<Response> {
    let { query, headers, ...rest } = params ?? {}
    const init = {
      ...this.requestInit,
      ...rest,
      method,
      body: body ?? null
    }

    // Merge our headers with any predefined headers
    init.headers = { ...this.headers, ...init.headers, ...headers }

    // If authorization data generator is present, call it and add the returned data to the request
    let authData: string | undefined
    if (this.authGenerator) {
      authData = this.authGenerator()
    }

    // If we now have authentication data, add it to the request
    if (authData) {
      init.headers['Authorization'] = 'Bearer ' + authData
    }

    // Make the actual request
    const queryString = query ? '?' + encodeQuery(query) : ''
    const response = await this.fetcher(this.baseURL + path + queryString, init)

    // handle any error responses
    if (!response.ok) {
      // try and get the error message from the response body
      let body: APIErrorResponse = {
        code: ErrCode.Unknown,
        message: `request failed: status ${response.status}`
      }

      // if we can get the structured error we should, otherwise give a best effort
      try {
        const text = await response.text()

        try {
          const jsonBody = JSON.parse(text)
          if (isAPIErrorResponse(jsonBody)) {
            body = jsonBody
          } else {
            body.message += ': ' + JSON.stringify(jsonBody)
          }
        } catch {
          body.message += ': ' + text
        }
      } catch (e) {
        // otherwise we just append the text to the error message
        body.message += ': ' + String(e)
      }

      throw new APIError(response.status, body)
    }

    return response
  }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
  code: ErrCode
  message: string
  details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
  return (
    err !== undefined &&
    err !== null &&
    isErrCode(err.code) &&
    typeof err.message === 'string' &&
    (err.details === undefined ||
      err.details === null ||
      typeof err.details === 'object')
  )
}

function isErrCode(code: any): code is ErrCode {
  return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
  /**
   * The HTTP status code associated with the error.
   */
  public readonly status: number

  /**
   * The Encore error code
   */
  public readonly code: ErrCode

  /**
   * The error details
   */
  public readonly details?: any

  constructor(status: number, response: APIErrorResponse) {
    // extending errors causes issues after you construct them, unless you apply the following fixes
    super(response.message)

    // set error name as constructor name, make it not enumerable to keep native Error behavior
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
    Object.defineProperty(this, 'name', {
      value: 'APIError',
      enumerable: false,
      configurable: true
    })

    // fix the prototype chain
    if ((Object as any).setPrototypeOf == undefined) {
      ;(this as any).__proto__ = APIError.prototype
    } else {
      Object.setPrototypeOf(this, APIError.prototype)
    }

    // capture a stack trace
    if ((Error as any).captureStackTrace !== undefined) {
      ;(Error as any).captureStackTrace(this, this.constructor)
    }

    this.status = status
    this.code = response.code
    this.details = response.details
  }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
  return err instanceof APIError
}

export enum ErrCode {
  /**
   * OK indicates the operation was successful.
   */
  OK = 'ok',

  /**
   * Canceled indicates the operation was canceled (typically by the caller).
   *
   * Encore will generate this error code when cancellation is requested.
   */
  Canceled = 'canceled',

  /**
   * Unknown error. An example of where this error may be returned is
   * if a Status value received from another address space belongs to
   * an error-space that is not known in this address space. Also
   * errors raised by APIs that do not return enough error information
   * may be converted to this error.
   *
   * Encore will generate this error code in the above two mentioned cases.
   */
  Unknown = 'unknown',

  /**
   * InvalidArgument indicates client specified an invalid argument.
   * Note that this differs from FailedPrecondition. It indicates arguments
   * that are problematic regardless of the state of the system
   * (e.g., a malformed file name).
   *
   * This error code will not be generated by the gRPC framework.
   */
  InvalidArgument = 'invalid_argument',

  /**
   * DeadlineExceeded means operation expired before completion.
   * For operations that change the state of the system, this error may be
   * returned even if the operation has completed successfully. For
   * example, a successful response from a server could have been delayed
   * long enough for the deadline to expire.
   *
   * The gRPC framework will generate this error code when the deadline is
   * exceeded.
   */
  DeadlineExceeded = 'deadline_exceeded',

  /**
   * NotFound means some requested entity (e.g., file or directory) was
   * not found.
   *
   * This error code will not be generated by the gRPC framework.
   */
  NotFound = 'not_found',

  /**
   * AlreadyExists means an attempt to create an entity failed because one
   * already exists.
   *
   * This error code will not be generated by the gRPC framework.
   */
  AlreadyExists = 'already_exists',

  /**
   * PermissionDenied indicates the caller does not have permission to
   * execute the specified operation. It must not be used for rejections
   * caused by exhausting some resource (use ResourceExhausted
   * instead for those errors). It must not be
   * used if the caller cannot be identified (use Unauthenticated
   * instead for those errors).
   *
   * This error code will not be generated by the gRPC core framework,
   * but expect authentication middleware to use it.
   */
  PermissionDenied = 'permission_denied',

  /**
   * ResourceExhausted indicates some resource has been exhausted, perhaps
   * a per-user quota, or perhaps the entire file system is out of space.
   *
   * This error code will be generated by the gRPC framework in
   * out-of-memory and server overload situations, or when a message is
   * larger than the configured maximum size.
   */
  ResourceExhausted = 'resource_exhausted',

  /**
   * FailedPrecondition indicates operation was rejected because the
   * system is not in a state required for the operation's execution.
   * For example, directory to be deleted may be non-empty, an rmdir
   * operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FailedPrecondition, Aborted, and Unavailable:
   *  (a) Use Unavailable if the client can retry just the failing call.
   *  (b) Use Aborted if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FailedPrecondition if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FailedPrecondition
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FailedPrecondition if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   *
   * This error code will not be generated by the gRPC framework.
   */
  FailedPrecondition = 'failed_precondition',

  /**
   * Aborted indicates the operation was aborted, typically due to a
   * concurrency issue like sequencer check failures, transaction aborts,
   * etc.
   *
   * See litmus test above for deciding between FailedPrecondition,
   * Aborted, and Unavailable.
   */
  Aborted = 'aborted',

  /**
   * OutOfRange means operation was attempted past the valid range.
   * E.g., seeking or reading past end of file.
   *
   * Unlike InvalidArgument, this error indicates a problem that may
   * be fixed if the system state changes. For example, a 32-bit file
   * system will generate InvalidArgument if asked to read at an
   * offset that is not in the range [0,2^32-1], but it will generate
   * OutOfRange if asked to read from an offset past the current
   * file size.
   *
   * There is a fair bit of overlap between FailedPrecondition and
   * OutOfRange. We recommend using OutOfRange (the more specific
   * error) when it applies so that callers who are iterating through
   * a space can easily look for an OutOfRange error to detect when
   * they are done.
   *
   * This error code will not be generated by the gRPC framework.
   */
  OutOfRange = 'out_of_range',

  /**
   * Unimplemented indicates operation is not implemented or not
   * supported/enabled in this service.
   *
   * This error code will be generated by the gRPC framework. Most
   * commonly, you will see this error code when a method implementation
   * is missing on the server. It can also be generated for unknown
   * compression algorithms or a disagreement as to whether an RPC should
   * be streaming.
   */
  Unimplemented = 'unimplemented',

  /**
   * Internal errors. Means some invariants expected by underlying
   * system has been broken. If you see one of these errors,
   * something is very broken.
   *
   * This error code will be generated by the gRPC framework in several
   * internal error conditions.
   */
  Internal = 'internal',

  /**
   * Unavailable indicates the service is currently unavailable.
   * This is a most likely a transient condition and may be corrected
   * by retrying with a backoff. Note that it is not always safe to retry
   * non-idempotent operations.
   *
   * See litmus test above for deciding between FailedPrecondition,
   * Aborted, and Unavailable.
   *
   * This error code will be generated by the gRPC framework during
   * abrupt shutdown of a server process or network connection.
   */
  Unavailable = 'unavailable',

  /**
   * DataLoss indicates unrecoverable data loss or corruption.
   *
   * This error code will not be generated by the gRPC framework.
   */
  DataLoss = 'data_loss',

  /**
   * Unauthenticated indicates the request does not have valid
   * authentication credentials for the operation.
   *
   * The gRPC framework will generate this error code when the
   * authentication metadata is invalid or a Credentials callback fails,
   * but also expect authentication middleware to generate it.
   */
  Unauthenticated = 'unauthenticated'
}
